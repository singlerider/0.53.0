// %BANNER_BEGIN%
// ---------------------------------------------------------------------
// %COPYRIGHT_BEGIN%
//
// Copyright (c) 2019 Magic Leap, Inc. All Rights Reserved.
// Use of this file is governed by your Early Access Terms and Conditions.
// This software is an Early Access Product.
//
// %COPYRIGHT_END%
// ---------------------------------------------------------------------
// %BANNER_END%

using System;
using System.Collections.Generic;
using System.Threading;
#if UNITY_MAGICLEAP || UNITY_ANDROID
using static UnityEngine.XR.MagicLeap.MLWebRTC.VideoSink.Frame;
#endif

namespace UnityEngine.XR.MagicLeap
{
    public partial class MLWebRTC
    {
        /// <summary>
        /// Demonstrates using the MLCamera as an app defined video source.
        /// </summary>
        public class MLCameraVideoSource : AppDefinedVideoSource
        {
#if UNITY_MAGICLEAP || UNITY_ANDROID
            private MLCameraVideoSource(MLCamera camera, MLCamera.CaptureConfig captureConfig, string trackId, Renderer localRenderer)
                : base(trackId)
            {
                this.camera = camera;
                this.captureConfig = captureConfig;

                previewRenderer = localRenderer;
                

                MLDevice.RegisterUpdate(Update);
            }

            ~MLCameraVideoSource()
            {
                MLDevice.UnregisterUpdate(Update);
            }

            private void CameraRecorderSurface_OnFrameAvailable()
            {
                surfaceFrameAvailable = 1;
            }


            private CircularBuffer<PlaneInfo[]> imagePlanesBuffer = CircularBuffer<PlaneInfo[]>.Create(
                new PlaneInfo[NativeImagePlanesLength[OutputFormat.YUV_420_888]],
                new PlaneInfo[NativeImagePlanesLength[OutputFormat.YUV_420_888]],
                new PlaneInfo[NativeImagePlanesLength[OutputFormat.YUV_420_888]]);

            private MLCamera camera;
            private MLCamera.CaptureConfig captureConfig;
            private MLNativeSurface cameraRecorderSurface;
            private NativeBufferInfo nativeBufferInfo;
            private Renderer previewRenderer;

            private bool isCapturing = false;
            private bool shouldStopCapturing = false;
            private int surfaceFrameAvailable = 0;
            private bool isCapturingPreview = false;
            private float previewAspectRatio = 0;

            public bool IsCapturing => isCapturing;

            private static readonly ushort captureBufferCount = 4;

            /// <summary>
            /// Developer should've created the MLCamera object, queried the
            /// stream capabilities, selected one & populated a MLCamera.CaptureConfig
            /// object with it. Developers are NOT required to setup any native surface
            /// in the capture config. The CaptureConfig should contain at a minimum
            /// a StreamConfig with CaptureType Video in the first array position, and optionally
            /// a second StreamConfig with CaptureType Preview if the call app wishes to display
            /// camera preview.
            /// Developer should NOT have called MLCamera.PrepareCapture() or
            /// any other capture functions on the camera object.
            /// </summary>
            /// <param name="camera">The MLCamera used to provide the video source for the Track.</param>
            /// <param name="captureConfig">The CaptureConfig should be configured prior to calling. The StreamConfigs array must contain a StreamConfig with CaptureType Video at index 0 
            /// and optionally a second with CaptureType Preview to enable rendering the MLCamera.PreviewTexture</param>
            /// <param name="result">The MLResult generated by attempting to initialize this AppDefinedVideoSource.</param>
            /// <param name="trackId">An optional track ID</param>
            /// <param name="localRenderer">Optional Unity Renderer component configured in the scene to display the MLCamera.PreviewTexture.</param>
            /// <returns></returns>
            public static MLCameraVideoSource CreateLocal(MLCamera camera, MLCamera.CaptureConfig captureConfig, out MLResult result, string trackId = "", Renderer localRenderer = null)
            {
                if (!MLResult.DidNativeCallSucceed(MLPermissions.CheckPermission(MLPermission.Camera).Result, nameof(CreateLocal)))
                {
                    MLPluginLog.Error($"{nameof(MLCameraVideoSource)} requires missing permission {MLPermission.Camera}");
                    result = MLResult.Create(MLResult.Code.PermissionDenied);
                    return null;
                }

                if (camera == null || captureConfig.StreamConfigs == null || captureConfig.StreamConfigs.Length < 1)
                {
                    result = MLResult.Create(MLResult.Code.InvalidParam);
                    return null;
                }

                MLCameraVideoSource mlCameraVideoSource = new MLCameraVideoSource(camera, captureConfig, trackId, localRenderer);
                result = InitializeLocal(mlCameraVideoSource);
                if (!result.IsOk)
                {
                    Debug.LogError($"MLCameraVideoSource.InitializeLocal failed with result {result}");
                    return null;
                }

                mlCameraVideoSource.StartCapture();

                return mlCameraVideoSource;
            }

            protected override void OnSourceSetEnabled(bool enabled)
            {
                if (enabled)
                {
                    StartCapture();
                }
                else
                {
                    StopCapture();
                }
            }

            protected override void OnSourceDestroy()
            {
                StopCapture();
            }

            private void ConfigureRecorderSurface()
            { 
                cameraRecorderSurface = new MLNativeSurface(MLNativeSurface.PixelFormat.Rgba8888, captureBufferCount, (uint)captureConfig.StreamConfigs[0].Width, (uint)captureConfig.StreamConfigs[0].Height);
                cameraRecorderSurface.OnFrameAvailable += CameraRecorderSurface_OnFrameAvailable;

                this.captureConfig.StreamConfigs[0].Surface = cameraRecorderSurface;

                nativeBufferInfo = new NativeBufferInfo();
                nativeBufferInfo.Width = (uint)captureConfig.StreamConfigs[0].Width;
                nativeBufferInfo.Height = (uint)captureConfig.StreamConfigs[0].Height;
                nativeBufferInfo.SurfaceHandle = cameraRecorderSurface.Handle;
                nativeBufferInfo.Transform = new float[16];
            }

            private void AdjustPreviewDimensions(float textureWidth, float textureHeight, Renderer renderer)
            {
                if (textureHeight == 0)
                {
                    Debug.LogError("AdjustPreviewDimensions can't scale renderer because it received a textureHeight of 0");
                    return;
                }

                float ratio = textureWidth / textureHeight;

                if (Math.Abs(previewAspectRatio - ratio) < float.Epsilon)
                    return;

                previewAspectRatio = ratio;
                var localScale = renderer.transform.localScale;
                localScale = new Vector3(previewAspectRatio * localScale.y, localScale.y, 1);
                renderer.transform.localScale = localScale;
            }

            private void StartCapture()
            {
                if (!isCapturing)
                {
                    Debug.Log("StartCapture with stream config: " + captureConfig.StreamConfigs[0]);

                    ConfigureRecorderSurface();

                    SetupCameraCallbacks();

                    var metadata = new MLCamera.Metadata(Native.MagicLeapNativeBindings.InvalidHandle);
                    MLResult result = camera.PrepareCapture(captureConfig, out metadata);
                    if (result.IsOk)
                    {
                        result = camera.PreCaptureAEAWB();
                        if (result.IsOk)
                        {
                            if (previewRenderer != null)
                            {
                                foreach (var config in captureConfig.StreamConfigs)
                                {
                                    if (config.CaptureType == MLCamera.CaptureType.Preview)
                                    {
                                        if(camera.CapturePreviewStart().IsOk)
                                        {
                                            isCapturingPreview = true;
                                        }
                                        break;
                                    }
                                }
                                if (isCapturingPreview)
                                {
                                    AdjustPreviewDimensions(camera.PreviewTexture.width, camera.PreviewTexture.height, previewRenderer);
                                    previewRenderer.enabled = true;
                                    previewRenderer.material.mainTexture = camera.PreviewTexture;
                                }
                            }
                            result = camera.CaptureVideoStart();
                        }
                    }

                    isCapturing = result.IsOk;
                }
            }

            private void StopCapture()
            {
                if (isCapturing)
                {
                    shouldStopCapturing = true;
                }
            }

            private void SetupCameraCallbacks()
            {
                if(camera != null)
                {
                    camera.OnCaptureAborted += Camera_OnCaptureAborted;
                    camera.OnCaptureFailed += Camera_OnCaptureFailed;
                    camera.OnDeviceDisconnected += Camera_OnDeviceDisconnected;
                    camera.OnDeviceIdle += Camera_OnDeviceIdle;
                    camera.OnDeviceError += Camera_OnDeviceError;
                    camera.OnDeviceStreaming += Camera_OnDeviceStreaming;
                }
            }

            private void RemoveCameraCallbacks()
            {
                if(camera != null)
                {
                    camera.OnCaptureAborted -= Camera_OnCaptureAborted;
                    camera.OnCaptureFailed -= Camera_OnCaptureFailed;
                    camera.OnDeviceDisconnected -= Camera_OnDeviceDisconnected;
                    camera.OnDeviceIdle -= Camera_OnDeviceIdle;
                    camera.OnDeviceError -= Camera_OnDeviceError;
                    camera.OnDeviceStreaming -= Camera_OnDeviceStreaming;
                }
            }

            /// <summary>
            /// Called via MLDevice
            /// </summary>
            private void Update()
            {
                if (isCapturing)
                {
                    // This needs to be an atomic operation because CameraRecorderSurface_OnFrameAvailable is called on a different thread than this func.
                    bool acquireNewFrame = (System.Threading.Interlocked.Exchange(ref surfaceFrameAvailable, 0) == 1);

                    if (acquireNewFrame)
                    {
                        cameraRecorderSurface.GetFrameNumber(out ulong frameId);
                        cameraRecorderSurface.GetFrameTimestamp(out long timestampNs);
                        cameraRecorderSurface.GetFrameTransformMatrix(nativeBufferInfo.Transform);
                        // DO NOT release the frame acquired here. It will be done by the underlying webrtc lib.
                        if (cameraRecorderSurface.AcquireNextAvailableFrame(out ulong nativeBufferHandle).IsOk)
                        {
                            nativeBufferInfo.NativeBufferHandle = nativeBufferHandle;
                            VideoSink.Frame frame = VideoSink.Frame.Create(frameId, (ulong)timestampNs / 1000, nativeBufferInfo);
                            _ = PushFrameAsync(frame);
                        }
                    }

                    if (shouldStopCapturing)
                    {
                        cameraRecorderSurface.OnFrameAvailable -= CameraRecorderSurface_OnFrameAvailable;

                        camera.CaptureVideoStop();
                        if (isCapturingPreview)
                        {
                            camera.CapturePreviewStop();
                            isCapturingPreview = false;
                        }
                        shouldStopCapturing = false;
                        isCapturing = false;
                        RemoveCameraCallbacks();
                        cameraRecorderSurface = null; 
                        captureConfig.StreamConfigs[0].Surface = null;
                        return;
                    }
                }
            }

            private void Camera_OnDeviceError(MLCamera.ErrorType error)
            {
                MLPluginLog.Error($"MLWebRTC.CameraVideoSource camera device error: {error}");
            }

            private void Camera_OnDeviceIdle()
            {
                MLPluginLog.Debug("MLWebRTC.CameraVideoSource camera is idle");
            }

            private void Camera_OnDeviceDisconnected(MLCamera.DisconnectReason reason)
            {
                MLPluginLog.Debug($"MLWebRTC.CameraVideoSource camera disconnected. reason: {reason}");
            }

            private void Camera_OnCaptureFailed(MLCamera.ResultExtras extra)
            {
                MLPluginLog.Error($"MLWebRTC.CameraVideoSource camera capture failed [frame: {extra.FrameNumber} timestamp: {extra.VCamTimestamp}]");
            }

            private void Camera_OnCaptureAborted()
            {
                MLPluginLog.Error($"MLWebRTC.CameraVideoSource camera capture aborted");
            }

            private void Camera_OnDeviceStreaming()
            {
                MLPluginLog.Debug("MLWebRTC.CameraVideoSource camera is streaming.");
            }
#else
            public MLCameraVideoSource(string trackId) : base(trackId)
            {
            }

            protected override void OnSourceDestroy()
            {
                throw new NotImplementedException();
            }

            protected override void OnSourceSetEnabled(bool enabled)
            {
                throw new NotImplementedException();
            }
#endif
        }
    }
}
